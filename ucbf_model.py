# -*- coding: utf-8 -*-
"""baseline_UCBF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xlUG7QUP5IvU-9qwguSQWyW9SPEWHTAI

# Load Datasets
"""

# Load datasets
import pandas as pd
track_df = pd.read_csv('/content/track_dataset.csv')
playlist_df = pd.read_csv('/content/playlist_dataset.csv')
user_df = pd.read_csv('/content/user_dataset.csv')

# Convert lists to proper list-string format after loading csv
import ast
user_df['playlists'] = user_df['playlists'].apply(ast.literal_eval)
playlist_df['track_list'] = playlist_df['track_list'].apply(ast.literal_eval)

print('Track_df:\n', track_df.columns)
print('\nPlaylist_df:\n', playlist_df.columns)
print('\nUser_df:\n', user_df.columns)

"""#Pre-processing --> for Collaborative Filtering, filter out tracks that no users listened to
reduces the user-item matrix size
"""

# Filter tracks that have at least one interaction
def filter_tracks_with_interactions(playlist_df, track_df):
    # Get all track_ids that are in playlists
    tracks_in_playlists = playlist_df['track_list'].sum()  # Flatten the lists
    tracks_with_interactions = set(tracks_in_playlists)

    # Filter track_df to keep only tracks with interactions
    filtered_track_df = track_df[track_df['track_id'].isin(tracks_with_interactions)]
    return filtered_track_df

# Apply the filter
filtered_track_df = filter_tracks_with_interactions(playlist_df, track_df)
print(track_df.shape)
print(filtered_track_df.shape)

"""# Pre-processing --> Stratified train-test split
training data gets 80% of each user's playlists
"""

from sklearn.model_selection import train_test_split

# Step 1: Split Playlists by User
def split_playlists(user_df, playlist_df):

    train_user_df = pd.DataFrame()
    test_user_df = pd.DataFrame()

    for user_id in user_df['user_id']:
        # Get the list of playlists for the user
        user_playlists_list = user_df[user_df['user_id'] == user_id]['playlists'].values[0]

        # Get all of the playlists from playlist_df
        user_playlists_df = playlist_df[playlist_df['playlist_id'].isin(user_playlists_list)]

        ###### USE THIS ONCE USER_DF GENERATION ALLOWS FOR STRATIFICATION ON GENRE & MOOD
        # # Create a third column to be used for stratification
        # user_playlists_df['mood_genre_stratification'] = playlist_df['overall_genre'] + '_' + playlist_df['overall_mood']
        # # Perform stratified split on combined column
        # train, test = train_test_split(user_playlists_df, test_size=0.2, random_state=1, stratify=user_playlists_df['mood_genre_stratification'])

        train, test = train_test_split(user_playlists_df, test_size=0.2, random_state=1)

        # Add to train set
        train_row = {'user_id':user_id, 'preferred_genres':user_df[user_df['user_id'] == user_id]['preferred_genres'], 'playlists':train['playlist_id'].tolist()}
        train_user_df = pd.concat([train_user_df, pd.DataFrame([train_row])], ignore_index=True)

        # Add to test set
        test_row = {'user_id':user_id, 'preferred_genres':user_df[user_df['user_id'] == user_id]['preferred_genres'], 'playlists':test['playlist_id'].tolist()}
        test_user_df = pd.concat([test_user_df, pd.DataFrame([test_row])], ignore_index=True)


    return train_user_df, test_user_df

train_user_df, test_user_df = split_playlists(user_df, playlist_df)

print(train_user_df.head())
print(test_user_df.head())

"""# Implementation --> Collaborative Filtering
### Create Weighted User-Item Interaction Matrix
"""

# Step 2: Create Weighted User-Item Interaction Matrix
def create_weighted_user_item_matrix(train_user_df, playlist_df, track_df):
    """
    Create a weighted user-item interaction matrix with interaction counts.

    Parameters:
    - train_user_df: DataFrame linking users to playlists in the training set.
    - playlist_df: DataFrame with playlist information.
    - track_df: Filtered DataFrame with track information (tracks with at least one interaction).

    Returns:
    - user_item_matrix: DataFrame with users as rows, tracks as columns, and interaction counts as values.
    """
    # Get the list of unique users and tracks
    user_ids = train_user_df['user_id'].unique()
    track_ids = track_df['track_id'].unique()

    # Initialize the user-item matrix with zeros
    user_item_matrix = pd.DataFrame(0, index=user_ids, columns=track_ids)

    # Populate the matrix
    for _, row in train_user_df.iterrows():
        user_id = row['user_id']
        playlists = row['playlists']

        # Get all tracks in the user's playlists
        user_tracks = playlist_df[playlist_df['playlist_id'].isin(playlists)][['track_list', 'playlist_id']]

        # Flatten the track lists and count occurrences
        for _, playlist_row in user_tracks.iterrows():
            track_list = playlist_row['track_list']  # List of tracks in this playlist
            for track_id in track_list:
                if track_id in user_item_matrix.columns:
                    user_item_matrix.loc[user_id, track_id] += 1  # Increment count

    return user_item_matrix

# Create the weighted user-item interaction matrix
weighted_user_item_matrix = create_weighted_user_item_matrix(train_user_df, playlist_df, filtered_track_df)

print("Weighted User-Item Interaction Matrix:")
print(weighted_user_item_matrix.head(1))

"""# Implementation --> User-Based Collaborative Filtering Baseline
### Compute the User-User Similarity Matrix
"""

from sklearn.metrics.pairwise import cosine_similarity
import numpy as np

# Step 3: Compute User-User Similarity
def compute_user_similarity(user_item_matrix):
    """
    Compute cosine similarity between users based on the user-item matrix.

    Parameters:
    - user_item_matrix: DataFrame with users as rows and items as columns.

    Returns:
    - user_similarity_matrix: DataFrame with users as both rows and columns,
                              containing pairwise similarity scores.
    """
    # Compute cosine similarity
    similarity_matrix = cosine_similarity(user_item_matrix)

    # Convert to DataFrame for better readability
    user_similarity_matrix = pd.DataFrame(
        similarity_matrix,
        index=user_item_matrix.index,
        columns=user_item_matrix.index
    )

    return user_similarity_matrix

# Compute user-user similarity
user_similarity_matrix = compute_user_similarity(weighted_user_item_matrix)

print("User-User Similarity Matrix:")
print(user_similarity_matrix.head())

"""# Recommendation Function --> User-Based Collaborative Filtering Baseline
### non-subsetted version
"""

def recommend_ubcf(user_id, user_item_matrix, user_similarity_matrix, top_n_similar=5, top_n_recommendations=10):
    """
    Generate recommendations for a target user using User-Based Collaborative Filtering.

    Parameters:
    - user_id: Target user ID.
    - user_item_matrix: User-item interaction matrix.
    - user_similarity_matrix: User-user similarity matrix.
    - top_n_similar: Number of similar users to consider.
    - top_n_recommendations: Number of recommendations to generate.

    Returns:
    - recommendations: A sorted list of recommended items (tracks) with scores.
    """
    # Get the similarity scores for the target user
    user_similarities = user_similarity_matrix[user_id].sort_values(ascending=False)

    # Exclude the target user from their own similarity scores
    user_similarities = user_similarities.drop(user_id)

    # Select the top-N most similar users
    top_similar_users = user_similarities.head(top_n_similar)

    # Aggregate item scores from similar users
    recommendation_scores = np.zeros(user_item_matrix.shape[1])  # Placeholder for scores
    for similar_user, similarity_score in top_similar_users.items():
        # Get the items interacted by the similar user
        similar_user_items = user_item_matrix.loc[similar_user]
        # Add the weighted score of these items
        recommendation_scores += similar_user_items.values * similarity_score

    # Convert scores back to a pandas Series for easier handling
    recommendation_scores = pd.Series(recommendation_scores, index=user_item_matrix.columns)

    # Exclude items the target user has already interacted with
    target_user_items = user_item_matrix.loc[user_id]
    recommendation_scores[target_user_items > 0] = 0

    # Sort the scores in descending order and return the top-N items
    recommendations = recommendation_scores.sort_values(ascending=False).head(top_n_recommendations)
    return recommendations

# Example Usage
target_user_id = '1'  # Replace with an actual user ID from your dataset
recommendations = recommend_ubcf(target_user_id, weighted_user_item_matrix, user_similarity_matrix)

print(f"Recommendations for {target_user_id}:")
print(recommendations)

"""# Recommendation Function --> User-Based Collaborative Filtering Baseline
### user-track subset filtered
"""

def recommend_ubcf_limited(user_id, user_item_matrix, user_similarity_matrix, valid_tracks, top_n_similar=5, top_n_recommendations=10):
    """
    Generate recommendations for a user limited to valid tracks from their track subset.

    Parameters:
    - user_id: Target user ID.
    - user_item_matrix: User-item interaction matrix.
    - user_similarity_matrix: User-user similarity matrix.
    - valid_tracks: List of valid track IDs to consider for recommendations.
    - top_n_similar: Number of similar users to consider.
    - top_n_recommendations: Number of recommendations to generate.

    Returns:
    - recommendations: A sorted list of recommended items (tracks) with scores, limited to valid tracks.
    """
    # Step 1: Get the similarity scores for the target user
    user_similarities = user_similarity_matrix[user_id].sort_values(ascending=False)
    user_similarities = user_similarities.drop(user_id)  # Exclude the target user

    # Step 2: Select the top-N most similar users
    top_similar_users = user_similarities.head(top_n_similar)

    # Step 3: Aggregate scores for all items
    recommendation_scores = np.zeros(user_item_matrix.shape[1])  # Placeholder for scores
    for similar_user, similarity_score in top_similar_users.items():
        similar_user_items = user_item_matrix.loc[similar_user]
        recommendation_scores += similar_user_items.values * similarity_score

    # Step 4: Convert scores to a pandas Series
    recommendation_scores = pd.Series(recommendation_scores, index=user_item_matrix.columns)

    # Step 5: Filter recommendations to valid tracks
    valid_recommendations = recommendation_scores[recommendation_scores.index.isin(valid_tracks)]
    valid_recommendations = valid_recommendations.sort_values(ascending=False)

    # Step 6: Ensure top_n_recommendations is met
    if len(valid_recommendations) < top_n_recommendations:
        # Get additional valid tracks not yet recommended
        additional_tracks = set(valid_tracks) - set(valid_recommendations.index)
        additional_recommendations = pd.Series(0, index=list(additional_tracks))  # Assign a score of 0 to additional tracks
        valid_recommendations = pd.concat([valid_recommendations, additional_recommendations])

    # Return exactly top_n_recommendations
    final_recommendations = valid_recommendations.sort_values(ascending=False).head(top_n_recommendations)

    return final_recommendations


# Example Usage
target_user_id = '1'  # Replace with an actual user ID from your dataset
recommendations = recommend_ubcf_limited(target_user_id, weighted_user_item_matrix, filtered_track_df, user_similarity_matrix)

print(f"Recommendations for {target_user_id}:")
print(recommendations)

"""# Evaluation

1. Iterate through each playlist for each user in the test set
2. Find the subset of tracks to evaluate on (instead of recommending on 100K, which is too hard, the subset is only tracks from that user's training & test set)
3. Generate recommendations specific to that user & mood (except baseline algorithms don't consider mood)
4. Evaluates the recommendationed tracks against the tracks in the test playlist using Precision, recall, cosine similarity


"""

def evaluate_recommender_algorthim(train_user_df, test_user_df, playlist_df, track_df, user_item_matrix, user_similarity_matrix, top_n_recommendations=10):
    detailed_results = []

    # Select only numeric feature columns
    feature_columns = track_df.select_dtypes(include=['float64', 'int64']).columns

    # Iterate through each user
    for _, test_row in test_user_df.iterrows():
        user_id = test_row['user_id']
        test_playlists = test_row['playlists']

        # Get valid tracks for the user (training and test playlists)
        user_playlists = train_user_df[train_user_df['user_id'] == user_id]['playlists'].values[0]
        valid_tracks = playlist_df[playlist_df['playlist_id'].isin(user_playlists + test_playlists)]['track_list'].sum()

        # Iterate through each test playlist
        for test_playlist_id in test_playlists:
            test_playlist = playlist_df[playlist_df['playlist_id'] == test_playlist_id]
            test_tracks = test_playlist['track_list'].values[0]  # Tracks in the playlist
            overall_mood = test_playlist['overall_mood'].values[0]  # Mood of the playlist



            ######################################
            # GENERATE RECOMMENDATIONS
            # (substitute recommendation function)
            ######################################
            recommendations = recommend_ubcf_limited(
                user_id=user_id,
                user_item_matrix=user_item_matrix,
                user_similarity_matrix=user_similarity_matrix,
                valid_tracks=valid_tracks,
                top_n_recommendations=top_n_recommendations
            )

            recommended_tracks = recommendations.index.tolist()
            #######################################



            # Calculate precision and recall
            hits = set(recommended_tracks).intersection(set(test_tracks))
            precision = len(hits) / len(recommended_tracks) if len(recommended_tracks) > 0 else 0
            recall = len(hits) / len(test_tracks) if len(test_tracks) > 0 else 0

            # Extract numeric features for cosine similarity
            test_track_features = track_df[track_df['track_id'].isin(test_tracks)][feature_columns].values
            recommended_track_features = track_df[track_df['track_id'].isin(recommended_tracks)][feature_columns].values

            if len(test_track_features) > 0 and len(recommended_track_features) > 0:
                cosine_sim = cosine_similarity(test_track_features, recommended_track_features).mean()
            else:
                cosine_sim = 0  # Default to 0 if no valid feature data

            detailed_results.append({
                'user_id': user_id,
                'playlist_id': test_playlist_id,
                'overall_mood': overall_mood,
                'precision': precision,
                'recall': recall,
                'cosine_similarity': cosine_sim
            })

    detailed_results_df = pd.DataFrame(detailed_results)
    return detailed_results_df


# Evaluate the recommender system
detailed_results_df = evaluate_recommender_algorthim(
    train_user_df=train_user_df,
    test_user_df=test_user_df,
    playlist_df=playlist_df,
    track_df=filtered_track_df,
    user_item_matrix=weighted_user_item_matrix,
    user_similarity_matrix=user_similarity_matrix
)

print("Detailed Results:")
print(detailed_results_df.head())

# Group by 'overall_mood' and compute mean for numeric columns
aggregated_metrics_by_mood = (
    detailed_results_df
    .groupby('overall_mood')[['precision', 'recall', 'cosine_similarity']]
    .mean()
)

# Compute overall metrics across all moods
overall_metrics = (
    detailed_results_df[['precision', 'recall', 'cosine_similarity']]
    .mean()
)

# Print the results
print("\nAggregated Metrics by Mood:")
print(aggregated_metrics_by_mood)

print("\nOverall Metrics:")
print(overall_metrics)

def recommend_ubcf_by_mood(user_id, user_item_matrix, user_similarity_matrix, mood, track_df, top_n_similar=5, top_n_recommendations=10):
    """
    Generate recommendations for a user based on their preferred mood using User-Based Collaborative Filtering.

    Parameters:
    - user_id: Target user ID.
    - user_item_matrix: User-item interaction matrix.
    - user_similarity_matrix: User-user similarity matrix.
    - mood: Target mood for filtering tracks.
    - track_df: DataFrame containing track information (including mood).
    - top_n_similar: Number of similar users to consider.
    - top_n_recommendations: Number of recommendations to generate.

    Returns:
    - recommendations: A sorted list of recommended tracks with scores, filtered by mood.
    """
    # Step 1: Filter tracks based on the target mood
    mood_tracks = track_df[track_df['mood'] == mood]['track_id'].tolist()

    # Step 2: Get the similarity scores for the target user
    user_similarities = user_similarity_matrix[user_id].sort_values(ascending=False)
    user_similarities = user_similarities.drop(user_id)  # Exclude the target user

    # Step 3: Select the top-N most similar users
    top_similar_users = user_similarities.head(top_n_similar)

    # Step 4: Aggregate scores for all items
    recommendation_scores = np.zeros(user_item_matrix.shape[1])  # Placeholder for scores
    for similar_user, similarity_score in top_similar_users.items():
        similar_user_items = user_item_matrix.loc[similar_user]
        recommendation_scores += similar_user_items.values * similarity_score

    # Step 5: Convert scores to a pandas Series
    recommendation_scores = pd.Series(recommendation_scores, index=user_item_matrix.columns)

    # Step 6: Filter recommendations to tracks matching the mood
    mood_recommendations = recommendation_scores[recommendation_scores.index.isin(mood_tracks)]

    # Step 7: Exclude items the target user has already interacted with
    target_user_items = user_item_matrix.loc[user_id]
    mood_recommendations[target_user_items > 0] = 0

    # Step 8: Sort the scores in descending order and return the top-N items
    recommendations = mood_recommendations.sort_values(ascending=False).head(top_n_recommendations)
    return recommendations

# Example Usage
target_user_id = '1'  # Replace with an actual user ID from your dataset
input_mood = 'happy'  # Example mood
recommendations_by_mood = recommend_ubcf_by_mood(target_user_id, weighted_user_item_matrix, user_similarity_matrix, input_mood, filtered_track_df)

print(f"Recommendations for {target_user_id} based on mood '{input_mood}':")
print(recommendations_by_mood)